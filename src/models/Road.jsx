/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useState, useRef } from "react";
import { useCurrentSheet } from "@theatre/r3f";
import { extend, useFrame } from "@react-three/fiber";
import { shaderMaterial, useGLTF, useScroll } from "@react-three/drei";
import { getProject, types, val } from "@theatre/core";
import { useControls } from "leva";
import "../utils/map";
import { editable as e } from "@theatre/r3f";

// Shader that fills the road with a color
const FillMaterial = shaderMaterial(
  { time: 0 },
  /*glsl*/ `
  varying vec2 vUv;
  varying vec3 vNormal;

  void main() {
    vUv = uv;
    vNormal = normal;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
  `,
  // fragment shader
  /*glsl*/ `
  uniform float time;
  varying vec2 vUv;
  varying vec3 vNormal;

  // This works backwards, flip x UVs in blender and re-export.
  void main() {
    // vec2 st = gl_FragCoord.xy/vUv.xy;

    // float strength = mod(vUv.x * 1.0, 1.0);
    float strength = mod(1.0 - vUv.x * 1.0, 1.0);
    float diff = gl_FragCoord.x - vUv.x;
    strength = step(time, strength);  
    vec3 initialColor = vec3(1.0, 1.0, 1.0);
    vec3 otherColor = vec3(0.0, 0.0, 0.0);
    vec3 color = mix(otherColor, initialColor, step(time, 1.0 - vUv.x));
    // strength *= strength * time;   
    
    gl_FragColor = vec4(color, step(time, 1.0 - vUv.x));
    
  }
  `
);

extend({ FillMaterial });

const Road = (props) => {
  const { nodes, materials } = useGLTF("/glb/road.glb");
  const [time, setTime] = useState(0.0);
  const [
    // The Theatre.js object that represents our THREE.js object. It'll be initially `null`.
    theatreObject,
    setTheatreObject,
  ] =
    // Let's use `useState()` so our `useEffect()` will re-run when `theatreObject` changes
    useState(null);
  const shaderRef = useRef();
  const meshRef = useRef();
  const sheet = useCurrentSheet();

  const stops = [0.38, 0.63];

  // sheet.sequence.position = 4.
  // useEffect(() => {
  //   const { project } = props;

  //   project.ready.then(() => {
  //     console.log("project is ready");
  //     // sheet.sequence.position = 2;
  //     // sheet.sequence.play({ range: [1, 4] });
  //     // sheet.sequence.play({ range: [1, 4] });
  //   });
  // }, []);

  // // This `useEffect()` will run when `theatreObject` changes
  // useEffect(
  //   () => {
  //     // if `theatreObject` is `null`, we don't need to do anything
  //     if (!theatreObject) return;

  //     const unsubscribe = theatreObject.onValuesChange((newValues) => {
  //       // Apply the new offset to our THREE.js object
  //       console.log(newValues.time);
  //     });
  //     // unsubscribe from the listener when the component unmounts
  //     return unsubscribe;
  //   },
  //   // We only want to run this `useEffect()` when `theatreObject` changes
  //   [theatreObject]
  // );

  // console.log(sheet.sequence.pointer.length);
  useFrame(({ clock }) => {
    const pos = sheet.sequence.position;

    theatreObject.onValuesChange((newValues) => {
      // Apply the new offset to our THREE.js object
      setTime(newValues.time);
    });

    // if (
    //   pos.map(0, val(sheet.sequence.pointer.length), 0, 1) <=
    //   stops[props.currDay - 1]
    // ) {
    //   console.log(
    //     "current pos: ",
    //     pos.map(0, val(sheet.sequence.pointer.length), 0, 1),
    //     "current stop: ",
    //     stops[props.currDay - 1]
    //   );
    //   setTime(pos.map(0, val(sheet.sequence.pointer.length), 0, 1));
    // }
  });

  // Controls for testing
  // const { time } = useControls({
  //   time: {
  //     min: 0,
  //     max: 1,
  //     value: 0.0,
  //     step: 0.001,
  //   },
  // });
  // const { positionX, positionY, positionZ, scale } = useControls({
  //   positionX: {
  //     value: -3.6,
  //     min: -5,
  //     max: 5,
  //     step: 0.001,
  //   },
  //   positionY: {
  //     value: 0.01,
  //     min: 0,
  //     max: 1,
  //     step: 0.025,
  //   },
  //   positionZ: {
  //     value: -0.7,
  //     min: -5,
  //     max: 5,
  //     step: 0.001,
  //   },
  //   scale: {
  //     value: 0.1,
  //     min: 0.005,
  //     max: 1,
  //     step: 0.01,
  //   },
  // });

  // checkPaused();

  // const time = 0;
  // if (!shaderRef.current) return null;
  return (
    <group {...props} dispose={null} position={[-3.6, 0.01, -0.7]}>
      <e.mesh
        theatreKey={"Road"}
        geometry={nodes.Road.geometry}
        scale={0.1}
        ref={meshRef}
        objRef={setTheatreObject}
        additionalProps={{
          time: types.number(0.5, { range: [0, 1.0] }),
        }}
      >
        {/* UVs are backwards so i'm flipping time here */}
        <fillMaterial transparent={true} time={1.0 - time} ref={shaderRef} />
      </e.mesh>
    </group>
  );
};

useGLTF.preload("/glb/road.glb");

export default Road;
