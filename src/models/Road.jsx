/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useState, useRef } from "react";
import { useCurrentSheet } from "@theatre/r3f";
import { extend, useFrame } from "@react-three/fiber";
import { shaderMaterial, useGLTF, useScroll } from "@react-three/drei";
import { getProject, val } from "@theatre/core";
import { useControls } from "leva";
import "../utils/map";

// Shader that fills the road with a color
const FillMaterial = shaderMaterial(
  { time: 0 },
  /*glsl*/ `
  varying vec2 vUv;
  varying vec3 vNormal;

  void main() {
    vUv = uv;
    vNormal = normal;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
  `,
  // fragment shader
  /*glsl*/ `
  uniform float time;
  varying vec2 vUv;
  varying vec3 vNormal;

  // This works backwards, flip x UVs in blender and re-export.
  void main() {
    // vec2 st = gl_FragCoord.xy/vUv.xy;

    // float strength = mod(vUv.x * 1.0, 1.0);
    float strength = mod(1.0 - vUv.x * 1.0, 1.0);
    float diff = gl_FragCoord.x - vUv.x;
    strength = step(time, strength);  
    vec3 initialColor = vec3(1.0, 1.0, 1.0);
    vec3 otherColor = vec3(0.0, 0.0, 0.0);
    vec3 color = mix(otherColor, initialColor, step(time, 1.0 - vUv.x));
    // strength *= strength * time;   
    
    gl_FragColor = vec4(color, step(time, 1.0 - vUv.x));
    
  }
  `
);

extend({ FillMaterial });

const Road = (props) => {
  const { nodes, materials } = useGLTF("/glb/road.glb");
  const [time, setTime] = useState(0.0);
  const shaderRef = useRef();
  const sheet = useCurrentSheet();

  const stops = [0.38, 0.63];

  // sheet.sequence.position = 4.
  // useEffect(() => {
  //   const { project } = props;

  //   project.ready.then(() => {
  //     console.log("project is ready");
  //     // sheet.sequence.position = 2;
  //     // sheet.sequence.play({ range: [1, 4] });
  //     // sheet.sequence.play({ range: [1, 4] });
  //   });
  // }, []);

  // console.log(sheet.sequence.pointer.length);
  useFrame(({ clock }) => {
    const pos = sheet.sequence.position;

    if (
      pos.map(0, val(sheet.sequence.pointer.length), 0, 1) <=
      stops[props.currDay - 1]
    ) {
      console.log(
        "current pos: ",
        pos.map(0, val(sheet.sequence.pointer.length), 0, 1),
        "current stop: ",
        stops[props.currDay - 1]
      );
      setTime(pos.map(0, val(sheet.sequence.pointer.length), 0, 1));
    }
  });

  // Controls for testing
  // const { time } = useControls({
  //   time: {
  //     min: 0,
  //     max: 1,
  //     value: 0.0,
  //     step: 0.001,
  //   },
  // });
  // const { positionX, positionY, positionZ, scale } = useControls({
  //   positionX: {
  //     value: -3.6,
  //     min: -5,
  //     max: 5,
  //     step: 0.001,
  //   },
  //   positionY: {
  //     value: 0.01,
  //     min: 0,
  //     max: 1,
  //     step: 0.025,
  //   },
  //   positionZ: {
  //     value: -0.7,
  //     min: -5,
  //     max: 5,
  //     step: 0.001,
  //   },
  //   scale: {
  //     value: 0.1,
  //     min: 0.005,
  //     max: 1,
  //     step: 0.01,
  //   },
  // });

  // checkPaused();

  // const time = 0;
  // if (!shaderRef.current) return null;
  return (
    <group {...props} dispose={null} position={[-3.6, 0.01, -0.7]}>
      <mesh geometry={nodes.Road.geometry} scale={0.1}>
        {/* UVs are backwards so i'm flipping time here */}
        <fillMaterial transparent={true} time={1.0 - time} ref={shaderRef} />
      </mesh>
    </group>
  );
};

useGLTF.preload("/glb/road.glb");

export default Road;
