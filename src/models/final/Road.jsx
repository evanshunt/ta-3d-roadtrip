/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef } from "react";
import { extend } from "@react-three/fiber";
import {
  shaderMaterial,
  useAnimations,
  useGLTF,
  useTexture,
} from "@react-three/drei";
import { useControls } from "leva";

// Shader that fills the road with a color
const FillMaterial = shaderMaterial(
  { time: 0 },
  /*glsl*/ `
    varying vec2 vUv;
    varying vec3 vNormal;
  
    void main() {
      vUv = uv;
      vNormal = normal;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position - time, 1.0);
    }
    `,
  // fragment shader
  /*glsl*/ `
    uniform float time;
    varying vec2 vUv;
    varying vec3 vNormal;
  
    // This works backwards, flip x UVs in blender and re-export.
    void main() {
      // vec2 st = gl_FragCoord.xy/vUv.xy;
  
      // float strength = mod(vUv.x * 1.0, 1.0);
    //   float strength = mod(1.0 - vUv.x * 1.0, 1.0);
    //   float diff = gl_FragCoord.x - vUv.x;
    //   strength = step(time, strength);  
    //   vec3 initialColor = vec3(1.0, 1.0, 1.0);
    //   vec3 otherColor = vec3(0.0, 0.0, 0.0);
    //   vec3 color = mix(otherColor, initialColor, step(time, 1.0 - vUv.x));
    //   // strength *= strength * time;   
      
    //   gl_FragColor = vec4(color, step(time, 1.0 - vUv.x));
      
    }
    `
);

extend({ FillMaterial });

function RoadThicc(props) {
  const shaderRef = useRef();
  const { nodes, materials } = useGLTF("/glb/final/road-y-up.glb");
  // const roadModel = useGLTF("/glb/final/road-with-animation-uncompressed.glb");
  // const animations = useAnimations(roadModel.animations, roadModel.scene);

  // const { animationName } = useControls({
  //   animationName: {
  //     options: animations.names,
  //   },
  // });
  //   const { animations, nodes, materials } = useGLTF(
  //     "/glb/final/road-with-animation-uncompressed.glb"
  //   );

  const texture = useTexture("/textures/final/road-baked-test.jpg");

  // useEffect(() => {
  //   const action = animations.actions[animationName];
  //   action.loop = true;
  //   action.reset().fadeIn(0.5).play();

  //   // window.setTimeout(() => {
  //   //   animations.actions.Survey.play()
  //   //   animations.actions.Survey.crossFadeFrom(animations.actions.Run, 1)
  //   // }, 2000)
  // }, [animationName]);

  const { editableTime, setEditableTime } = useControls({
    editableTime: {
      min: 0,
      max: 1,
      value: 0,
      step: 0.001,
    },
  });
  // const { posX, posY, posZ } = useControls({
  //     posX: {
  //         min: -8,
  //         max: 8,
  //         value: 0,
  //     },
  //     posY: {
  //         min: -8,
  //         max: 8,
  //         step: 0.01,
  //         value: 0,
  //     },
  //     posZ: {
  //         min: -8,
  //         max: 8,
  //         value: 0,
  //     }
  // })
  return (
    <group {...props} dispose={null}>
      {/* Primitive was for animation tests, but it seems like glb cant support curve animations? */}
      {/* <primitive
        object={roadModel.scene}
        scale={[0.25, 0.25, 0.25]}
        position={[0, -1.025, 0]}
        castShadow
        receiveShadow
        animations={animations}
      /> */}
      <mesh
        castShadow
        scale={0.25}
        geometry={nodes.BezierCurve.geometry}
        position={[0, -1.025, 0]}
      >
        <meshStandardMaterial
          roughness={0.6}
          metalness={0.8}
          color={0x9c0f00}
          // map={texture}
          // map-flipY={false}
          // map-generateMipmaps={true}
          // map-anisotropy={32}
        />
      </mesh>
    </group>
  );
}

useGLTF.preload("/glb/road.glb");

export default RoadThicc;
